diff --git a/renderdoc/api/replay/resourceid.h b/renderdoc/api/replay/resourceid.h
index cbb948cee..043298d69 100644
--- a/renderdoc/api/replay/resourceid.h
+++ b/renderdoc/api/replay/resourceid.h
@@ -76,7 +76,7 @@ struct ResourceId
   operator QVariant() const { return QVariant::fromValue(*this); }
 #endif
 
-private:
+public:
   uint64_t id;
 
 #ifdef RENDERDOC_EXPORTS
diff --git a/renderdoc/driver/gl/gl_driver.h b/renderdoc/driver/gl/gl_driver.h
index 6ff7a2670..ce7ab10c3 100644
--- a/renderdoc/driver/gl/gl_driver.h
+++ b/renderdoc/driver/gl/gl_driver.h
@@ -832,6 +832,8 @@ public:
   };
 
   std::map<ResourceId, TextureData> m_Textures;
+  std::map<ResourceId, bytebuf> m_texture3d;
+  std::map<ResourceId, ResourceId> m_texture3dMap;
 
   IMPLEMENT_FUNCTION_SERIALISED(void, glBindTexture, GLenum target, GLuint texture);
   IMPLEMENT_FUNCTION_SERIALISED(void, glBindTextures, GLuint first, GLsizei count,
diff --git a/renderdoc/driver/gl/gl_initstate.cpp b/renderdoc/driver/gl/gl_initstate.cpp
index 2488f602d..1f1a513c7 100644
--- a/renderdoc/driver/gl/gl_initstate.cpp
+++ b/renderdoc/driver/gl/gl_initstate.cpp
@@ -1665,7 +1665,18 @@ bool GLResourceManager::Serialise_InitialState(SerialiserType &ser, ResourceId i
                 else
                 {
                   // we avoid glGetTextureImageEXT as it seems buggy for cubemap faces
-                  GL.glGetTexImage(targets[trg], i, fmt, type, scratchBuf);
+                    if (targets[trg] == eGL_TEXTURE_3D && fmt == eGL_RGB && type == eGL_UNSIGNED_BYTE) {
+                        RDCLOG("i=%d, fmt=%s, type=%s, size=%llu", i, ToStr(fmt).c_str(), ToStr(type).c_str(), size);
+                        GLint boundTexture = 0;
+                        GL.glGetIntegerv(TextureBinding(targets[trg]), (GLint*)&boundTexture);
+                        ResourceId tex3d_id = m_Driver->GetResourceManager()->GetResID(TextureRes(m_Driver->GetCtx(), boundTexture));
+                        RDCLOG("width=%u, height=%u, depth=%u, tex3d_id=%llu", w, h, d, tex3d_id.id);
+
+                        rdcarray<byte>& cdData = m_Driver->m_texture3d[m_Driver->m_texture3dMap[tex3d_id]];
+                        memcpy(scratchBuf, cdData.data(), size);
+                    } else {
+                        GL.glGetTexImage(targets[trg], i, fmt, type, scratchBuf);
+                    }
                 }
               }
 
diff --git a/renderdoc/driver/gl/wrappers/gl_emulated.cpp b/renderdoc/driver/gl/wrappers/gl_emulated.cpp
index 16754ad81..c7e87f636 100644
--- a/renderdoc/driver/gl/wrappers/gl_emulated.cpp
+++ b/renderdoc/driver/gl/wrappers/gl_emulated.cpp
@@ -1309,8 +1309,14 @@ void APIENTRY _glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLev
     {
       GLenum status = GL.glCheckFramebufferStatus(eGL_DRAW_FRAMEBUFFER);
 
-      if(status != eGL_FRAMEBUFFER_COMPLETE)
+      if (status != eGL_FRAMEBUFFER_COMPLETE)
+      {
         RDCERR("glCopyImageSubData emulation draw FBO is %s", ToStr(status).c_str());
+        ResourceId src_id = driver->GetResourceManager()->GetResID(TextureRes(driver->GetCtx(), srcName));
+        ResourceId dst_id = driver->GetResourceManager()->GetResID(TextureRes(driver->GetCtx(), dstName));
+        RDCLOG("srcName=%u, srcTarget=%d, srcLevel=%d, srcX=%d, srcY=%d, srcZ=%d, dstName=%u, srcWidth=%d, srcHeight=%d, srcDepth=%d, id=%llu, id=%llu",
+            srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, srcWidth, srcHeight, srcDepth, src_id.id, dst_id.id);
+      }
 
       status = GL.glCheckFramebufferStatus(eGL_READ_FRAMEBUFFER);
 
@@ -1356,6 +1362,13 @@ void APIENTRY _glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLev
     }
     else
     {
+        if (srcTarget == eGL_TEXTURE_3D) {
+            ResourceId src_id = driver->GetResourceManager()->GetResID(TextureRes(driver->GetCtx(), srcName));
+            ResourceId dst_id = driver->GetResourceManager()->GetResID(TextureRes(driver->GetCtx(), dstName));
+            driver->m_texture3dMap[dst_id] = src_id;
+            RDCLOG("srcName=%u, srcTarget=%d, srcLevel=%d, srcX=%d, srcY=%d, srcZ=%d, dstName=%u, srcWidth=%d, srcHeight=%d, srcDepth=%d, id=%llu, id=%llu",
+                srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, srcWidth, srcHeight, srcDepth, src_id.id, dst_id.id);
+        }
       for(GLsizei slice = 0; slice < srcDepth; slice++)
       {
         GL.glFramebufferTextureLayer(eGL_READ_FRAMEBUFFER, attach, srcName, srcLevel, srcZ + slice);
@@ -2674,6 +2687,10 @@ void APIENTRY _glGetTexImage(GLenum target, GLint level, const GLenum format, co
 
   GLint boundTexture = 0;
   GL.glGetIntegerv(TextureBinding(target), (GLint *)&boundTexture);
+  if (target == eGL_TEXTURE_3D) {
+      ResourceId tex3d_id = driver->GetResourceManager()->GetResID(TextureRes(driver->GetCtx(), boundTexture));
+      RDCLOG("width=%d, height=%d, depth=%d, tex3d_id=%llu", width, height, depth, tex3d_id.id);
+  }
 
   GLuint readtex = boundTexture;
   GLuint deltex = 0;
diff --git a/renderdoc/driver/gl/wrappers/gl_texture_funcs.cpp b/renderdoc/driver/gl/wrappers/gl_texture_funcs.cpp
index ccfe86831..00bb1912f 100644
--- a/renderdoc/driver/gl/wrappers/gl_texture_funcs.cpp
+++ b/renderdoc/driver/gl/wrappers/gl_texture_funcs.cpp
@@ -3248,6 +3248,13 @@ void WrappedOpenGL::Common_glTextureImage3DEXT(ResourceId texId, GLenum target,
     m_Textures[texId].initFormatHint = format;
     m_Textures[texId].initTypeHint = type;
   }
+
+  if (target == eGL_TEXTURE_3D && format == eGL_RGB && type == eGL_UNSIGNED_BYTE && level == 0) {
+      rdcarray<byte>& cdData = m_texture3d[texId];
+      size_t imageSize = width * height * depth * 3;
+      cdData.resize(imageSize);
+      memcpy(cdData.data(), pixels, imageSize);
+  }
 }
 
 void WrappedOpenGL::glTextureImage3DEXT(GLuint texture, GLenum target, GLint level,
@@ -5726,6 +5733,15 @@ bool WrappedOpenGL::Serialise_glTextureSubImage3DEXT(SerialiserType &ser, GLuint
   if(!UnpackBufBound)
   {
     ser.Serialise("pixels"_lit, pixels, subimageSize, SerialiserFlags::AllocateMemory);
+
+    // control image size
+    if (ser.IsWriting() && pixels && target == eGL_TEXTURE_3D && format == eGL_RGB && type == eGL_UNSIGNED_BYTE && level == 0) {
+        ResourceId texId = GetResourceManager()->GetResourceRecord(texture)->GetResourceID();
+        rdcarray<byte>& cdData = m_texture3d[texId];
+        // size_t imageSize = width * height * depth * 3;
+        // cdData.resize(subimageSize);
+        memcpy(cdData.data(), pixels, subimageSize);
+    }
   }
   else
   {
